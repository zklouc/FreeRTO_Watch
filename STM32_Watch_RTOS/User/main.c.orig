#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "Serial.h"
#include "DS3231.h"
#include <string.h>
#include "ADXL345.h"
#include "Max30102.h"
#include "AD.h"
#include "Key.h"
#include "Encoder.h"
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"  // 这个头文件包含了与信号量相关的所有函数和类型定义

//实时时间
DS3231_TimeType DS3231_R_Time;	//日历结构体
int Last_Date;  //记录上一秒，用于更新
DS3231_TimeType AlarmTime;
volatile uint8_t alarm_flag=0;

//步数
uint8_t Active_axis=1;  //1-X,2-Y,3-Z 默认初始为x轴
Peak_Value Peak = {{0}, {0}, {0}};//ADXL345样本集中最大和最小值及差值
Slid_Reg Slid = {{0}, {0}};//移位寄存器高频滤波
Aver_Acc Cur_Sample;//ADCL345当前样本
uint8_t Step_Count=0;//步数
//心率血氧
uint32_t buffer_length=500; //缓冲区长度为500，可存储以100sps运行的5秒样本; 数据长度（红外光数据与红光数据数据长度相等）
uint32_t ir_buffer[500]; 	 //IR LED   红外光数据，用于计算血氧
uint32_t red_buffer[500];  //Red LED	红光数据，用于计算心率曲线以及计算心率
int32_t n_sp02=0; 				//SPO2值
int8_t ch_spo2_valid;   //用于显示SP02计算是否有效的指示符
int32_t n_heart_rate=0;   //心率值
int8_t  ch_hr_valid;    //用于显示心率计算是否有效的指示符
int index_count;
uint32_t un_min, un_max;  //存储红光数据的最小值和最大值，用于归一化处理
uint8_t dis_hr=0,dis_spo2=0;//用于显示的心率和血氧饱和度值

uint8_t UART_Star=0;
uint8_t Key_Num=0;
uint16_t BAT_Value=0;
int16_t Enc_Count=0;

QueueHandle_t inputQueue;//输入控制队列

TaskHandle_t xMainShow_TaskHandler; 
TaskHandle_t xMenuShow_TaskHandler; 
TaskHandle_t xSerial_TaskHandler;  
TaskHandle_t xKey_TaskHandler;
TaskHandle_t xSetClock_TaskHandler; 
TaskHandle_t xSetAlarm_TaskHandler; 
TaskHandle_t xADXL_TaskHandler; 
TaskHandle_t xMAX_TaskHandler; 

BaseType_t ret;											//动态内存分配返回结果
static SemaphoreHandle_t xOLED_Mutex;    		 //OLED的互斥锁


void MainShow_Task(void *params);
void MenuShow_Task(void *params);
void Serial_Task(void *params);
void Key_Task(void *params );
void SetClock_Task(void *params );
void SetAlarm_Task(void *params);
void ADXL_Task(void *params);
void DS_Task(void *params);
void MAX_Task(void *params);

void Max30102_Get(void);

int main(void)
{
  /*模块初始化*/
  OLED_Init();			//OLED初始化
  Serial_Init();
  ADXL345_Init();
  MAX30102_Init();
	DS3231_Init();
  AD_Init();
  Key_Init();
  Encoder_Init();
  OLED_Clear();
  OLED_Update();
  AlarmTime.hour = 14;
  AlarmTime.min = 36;
  AlarmTime.sec = 20;
  DS3231_Write_Alarm(AlarmTime);
//  //读取前500个样本，并确定信号范围
//  for(index_count=0; index_count<buffer_length; index_count++)
//  {
//    while(MAX30102_INT()==1);
//    MAX30102_FIFO_ReadWord(&red_buffer[index_count],&ir_buffer[index_count]);//获取红光和红外光的数据
//  }
//  //计算前500个样本（前5秒的样本）后的心率和血氧饱和度
//	maxim_heart_rate_and_oxygen_saturation(ir_buffer, buffer_length, red_buffer, &n_sp02, &ch_spo2_valid, &n_heart_rate, &ch_hr_valid); 
	OLED_ShowNum(44, 14,n_heart_rate,3,OLED_8X16);OLED_ShowNum(44,31,n_sp02,2,OLED_8X16);dis_hr=0;
	OLED_Update();
	xOLED_Mutex=xSemaphoreCreateMutex();
  // 输入事件队列 用于存储输入事件。队列的大小是10，意味着它可以同时存储10个事件
  inputQueue= xQueueCreate(10, sizeof(InputData));
	// 创建任务
	ret=xTaskCreate(MainShow_Task,"MainShow", 128, NULL, 3, &xMainShow_TaskHandler);//主显示
	ret=xTaskCreate(MenuShow_Task,"MenuShow", 128, NULL, 8, &xMenuShow_TaskHandler);//菜单切换
	ret=xTaskCreate(Serial_Task,  "Serial_Task",128, NULL, 3, &xSerial_TaskHandler);  //串口(蓝牙）
	ret=xTaskCreate(Key_Task,     "Key_Task", 128, NULL, 9, &xKey_TaskHandler);			//按键
	ret=xTaskCreate(SetClock_Task,"SetClock", 128, NULL, 5, &xSetClock_TaskHandler);//设置时间
	ret=xTaskCreate(SetAlarm_Task,"SetAlarm", 128, NULL, 5, &xSetAlarm_TaskHandler);//设置闹钟
	ret=xTaskCreate(ADXL_Task,    "ADXL_Task",128, NULL, 6, &xADXL_TaskHandler);		//步数检测
	ret=xTaskCreate(MAX_Task,     "MAX_Task", 128, NULL, 7, &xMAX_TaskHandler);			//心率血氧检测
	vTaskSuspend(xSetClock_TaskHandler);
	vTaskSuspend(xSetAlarm_TaskHandler);
	vTaskSuspend(xMAX_TaskHandler);
	vTaskSuspend(xSerial_TaskHandler);
	vTaskStartScheduler();          //开启任务调度
  while(1)
	{
     Serial_Printf( "Error\r\n");
	}
}

InputData menu_data;//获取到的队列数据
static int8_t Show_Page =0;

void MenuShow_Task(void *params)
{
	while(1)
	{ //一直等待按键或者旋转编码器,否则不进行菜单切换
		xQueueReceive( inputQueue,&menu_data,portMAX_DELAY );
		if((menu_data.id==ENC_ID)&&(menu_data.count==1))//正转
		{
			Show_Page++;
			if(Show_Page>3) Show_Page=0;
		}
		else if((menu_data.id==ENC_ID)&&(menu_data.count==-1))//反转
		{
			Show_Page--;
			if(Show_Page<0) Show_Page=3;
		}
		else if((menu_data.id==Key_ID)&&(menu_data.count==1))//短按
		{
			switch(Show_Page)
			{
				case 0:vTaskResume(xSetClock_TaskHandler);break;
				case 1:vTaskResume(xSetAlarm_TaskHandler);break;
				case 2:vTaskResume(xMAX_TaskHandler);break;
				case 3:vTaskResume(xSerial_TaskHandler);break;
			}
      vTaskSuspend(xMainShow_TaskHandler);
	    vTaskSuspend(xMenuShow_TaskHandler);				
		}
		else if((menu_data.id==Key_ID)&&(menu_data.count==2))//长按
		{
			  
		}
		taskENTER_CRITICAL();	
		Serial_Printf( "ID:%d,Count:%04d\r\n",menu_data.id, menu_data.count);
	  taskEXIT_CRITICAL();
		menu_data.count=0;
		menu_data.id=0;
		vTaskDelay(100); // 延时 100ms
	}
}

//主显示任务
void MainShow_Task(void *params)
{
	while(1)
	{
		switch(Show_Page)
		{
			case 0:
					taskENTER_CRITICAL();	
					DS3231_Read_Time(&DS3231_R_Time);
			    OLED_Clear();
			    OLED_ShowImage(2,1,16,8,Battery_Full);
			    OLED_ShowString(60,0,"steps:%5d",OLED_6X8);
			    OLED_ShowNum(96,0,Step_Count,5,OLED_6X8);//显示步数
			    OLED_DrawLine(0, 12, 127, 12);
					OLED_Printf(32, 18,OLED_8X16, "%02d-%02d-%02d", DS3231_R_Time.year, DS3231_R_Time.month, DS3231_R_Time.date); // 显示日期
					OLED_Printf(32, 40,OLED_8X16, "%02d:%02d:%02d", DS3231_R_Time.hour, DS3231_R_Time.min, DS3231_R_Time.sec); // 显示时间
					OLED_Update();
					taskEXIT_CRITICAL(); 
					break;
			case 1:
				taskENTER_CRITICAL();	
			  OLED_Clear();
				OLED_ShowString(10,20,"naozhongshezhi",OLED_8X16);
			  OLED_Update();
				taskEXIT_CRITICAL(); 
			  break;	
			case 2:
				taskENTER_CRITICAL();	
			  OLED_Clear();
				OLED_ShowString(10,20,"xinlvxueyang",OLED_8X16);
			  OLED_Update();
				taskEXIT_CRITICAL(); 
			  break;
			case 3:			
				taskENTER_CRITICAL();	
			  OLED_Clear();
				OLED_ShowString(10,20,"lanyachuanshu",OLED_8X16);
			  OLED_Update();
				taskEXIT_CRITICAL(); 
			  break;
		}	
//		
//		//闹钟响起
//		if(alarm_flag==0x01)
//    {
//      GPIO_ResetBits(GPIOA, GPIO_Pin_2);		//将PA2引脚设置为低电平，蜂鸣器鸣叫
//      vTaskDelay(100);							//延时100ms
//      GPIO_SetBits(GPIOA, GPIO_Pin_2);		//将PA2引脚设置为高电平，蜂鸣器停止
//      vTaskDelay(100);							//延时100ms
//    }
		vTaskDelay(150); // 延时 100ms
	}
}

void Serial_Task(void *params)
{
	  InputData BT_data;
    while (1)
    {
			xQueueReceive( inputQueue,&BT_data,10);
			taskENTER_CRITICAL();	
			OLED_Clear();
			OLED_Printf( 0,0,OLED_8X16,"ID:%d,Count:%04d",BT_data.id, BT_data.count);
			OLED_Update();
//				if (UART_Star == 1)		//	串口发送数据
//				{
//					Serial_Printf( "HeartRate:%03d,Blood Oxygen:%02d%,Steps:%05d",n_heart_rate, n_sp02,Step_Count);
//				}
//				else if(UART_Star==2) //串口停止发送数据
//				{
//					UART_Star = 0;
//				}
			Serial_Printf( "ID:%d,Count:%04d\r\n",BT_data.id, BT_data.count);
			taskEXIT_CRITICAL(); 
			if((BT_data.id==1)&&(BT_data.count==1)) 
			{
				vTaskResume(xMenuShow_TaskHandler);
				vTaskResume(xMainShow_TaskHandler);
				vTaskSuspend(NULL);
			}	
			BT_data.id=0;
			BT_data.count=0;
			vTaskDelay(100);
		}
}



void ADXL_Task(void *arg)
{
//    uint32_t last_activity = 0;
    while (1)
    {
			taskENTER_CRITICAL();
			ADXL345_Average(&Cur_Sample);
			taskEXIT_CRITICAL();
			Step_Count = Detect_Step(&Peak, &Slid, &Cur_Sample,&Active_axis); // 监测步数，显示步数		     
			vTaskDelay(150); // 延时 150ms
    }
}


    

void MAX_Task(void *arg)
{
	InputData HR_data;
	while(1)
	{
		xQueueReceive( inputQueue,&HR_data,10);
		taskENTER_CRITICAL();	
		OLED_Clear();
	 //显示“心率”
		OLED_ShowChinese(0,14,"心率");
		OLED_ShowChar(34,14,':',OLED_8X16	);
		OLED_ShowString(70,14,"BMP",OLED_8X16	);

		//显示“血氧”
		OLED_ShowChinese(0,31,"血氧");
		OLED_ShowChar(34,31,':',OLED_8X16	);
		OLED_ShowChar(70,31,'%',OLED_8X16	);
		  
		OLED_Printf( 0,0,OLED_8X16,"ID:%d,Count:%04d",HR_data.id, HR_data.count);
		OLED_Update();
		Serial_Printf( "ID:%d,Count:%04d\r\n",HR_data.id, HR_data.count);
		//		Max30102_Get();
		taskEXIT_CRITICAL(); 
		if((HR_data.id==1)&&(HR_data.count==1)) 
		{
			vTaskResume(xMenuShow_TaskHandler);
			vTaskResume(xMainShow_TaskHandler);
			vTaskSuspend(NULL);
		}	
		HR_data.id=0;
		HR_data.count=0;
		vTaskDelay(100);
	}
}

void Max30102_Get(void)
{
  for(index_count=100; index_count<buffer_length; index_count++)
  {
    red_buffer[index_count-100]=red_buffer[index_count];	//将100-500缓存数据移位到0-400
    ir_buffer[index_count-100] =ir_buffer[index_count];		//将100-500缓存数据移位到0-400
  }
  for(index_count=400; index_count<buffer_length; index_count++)
  {
    while(MAX30102_INT()==1);
    MAX30102_FIFO_ReadWord(&red_buffer[index_count],&ir_buffer[index_count]);//获取红光和红外光的数据
  }
  maxim_heart_rate_and_oxygen_saturation(ir_buffer, buffer_length, red_buffer, &n_sp02, &ch_spo2_valid, &n_heart_rate, &ch_hr_valid);
  if(ch_hr_valid == 1 && n_heart_rate<120)
  {
    n_heart_rate-=20;	//做补偿
    OLED_ShowNum(44, 14,n_heart_rate,3,OLED_8X16);
    OLED_ShowNum(44,31,n_sp02,2,OLED_8X16);
    dis_hr=n_heart_rate;
  }
  else if((n_heart_rate>120)&&(ch_hr_valid== 1)&&dis_hr>0)
  {
    n_heart_rate=dis_hr;
    OLED_ShowNum(44, 14,n_heart_rate,3,OLED_8X16);
    OLED_ShowNum(44,31,n_sp02,2,OLED_8X16);
    dis_hr=n_heart_rate;
  }
  else
  {
    n_heart_rate=0;
    n_sp02=0;
    OLED_ShowNum(44, 14,n_heart_rate,3,OLED_8X16);
    OLED_ShowNum(44,31,n_sp02,2,OLED_8X16);
    dis_hr=0;
  }
}

